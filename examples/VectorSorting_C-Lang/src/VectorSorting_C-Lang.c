#if defined(D_NEXYS_A7)
#include <bsp_printf.h>
#include <bsp_mem_map.h>
#include <bsp_version.h>
#else
PRE_COMPILED_MSG("no platform was defined")
#endif
#include <psp_api.h>

#include <stdlib.h>

#include <math.h>

//Butterfly computing unit
void butterfly(int * x1_r,int * x1_i,int * x2_r,int * x2_i , int * y1_r,int * y1_i,int * y2_r,int * y2_i , float w_r,float w_i)
{
    (*y1_r) = (*x1_r) + (*x2_r)*w_r - (*x2_i)*w_i;
    (*y1_i) = (*x1_i) + (*x2_r)*w_i + (*x2_i)*w_r;
    
    (*y2_r) = (*x1_r) - (*x2_r)*w_r + (*x2_i)*w_i;
    (*y2_i) = (*x1_i) - (*x2_r)*w_i - (*x2_i)*w_r;
}

int main(void)
{
    uartInit();

    //Real part of the twiddle factor
    float w_r [128] = {1,1,0.999,0.997,0.995,0.992,0.989,0.985,0.981,0.976,0.970,0.964,0.957,0.950,0.942,0.933,0.924,0.914,0.904,0.893,0.882,0.870,0.858,0.845,0.831,0.818,0.803,0.788,0.773,0.757,0.741,0.724,0.707,0.690,0.672,0.653,0.634,0.615,0.596,0.576,0.556,0.535,0.514,0.493,0.471,0.450,0.428,0.405,0.383,0.360,0.337,0.314,0.290,0.267,0.243,0.219,0.195,0.171,0.147,0.122,0.098,0.074,0.049,0.025,0,-0.025,-0.049,-0.074,-0.098,-0.122,-0.147,-0.171,-0.195,-0.219,-0.243,-0.267,-0.290,-0.314,-0.337,-0.360,-0.383,-0.405,-0.428,-0.450,-0.471,-0.493,-0.514,-0.535,-0.556,-0.576,-0.596,-0.615,-0.634,-0.653,-0.672,-0.690,-0.707,-0.724,-0.741,-0.757,-0.773,-0.788,-0.803,-0.818,-0.831,-0.845,-0.858,-0.870,-0.882,-0.893,-0.904,-0.914,-0.924,-0.933,-0.942,-0.950,-0.957,-0.964,-0.970,-0.976,-0.981,-0.985,-0.989,-0.992,-0.995,-0.997,-0.999,-1};
    //Imaginary part of the twiddle factor
    float w_i [128] = {0,-0.025,-0.049,-0.074,-0.098,-0.122,-0.147,-0.171,-0.195,-0.219,-0.243,-0.267,-0.290,-0.314,-0.337,-0.360,-0.383,-0.405,-0.428,-0.450,-0.471,-0.493,-0.514,-0.535,-0.556,-0.576,-0.596,-0.615,-0.634,-0.653,-0.672,-0.690,-0.707,-0.724,-0.741,-0.757,-0.773,-0.788,-0.803,-0.818,-0.831,-0.845,-0.858,-0.870,-0.882,-0.893,-0.904,-0.914,-0.924,-0.933,-0.942,-0.950,-0.957,-0.964,-0.970,-0.976,-0.981,-0.985,-0.989,-0.992,-0.995,-0.997,-0.999,-1,-1,-1,-0.999,-0.997,-0.995,-0.992,-0.989,-0.985,-0.981,-0.976,-0.970,-0.964,-0.957,-0.950,-0.942,-0.933,-0.924,-0.914,-0.904,-0.893,-0.882,-0.870,-0.858,-0.845,-0.831,-0.818,-0.803,-0.788,-0.773,-0.757,-0.741,-0.724,-0.707,-0.690,-0.672,-0.653,-0.634,-0.615,-0.596,-0.576,-0.556,-0.535,-0.514,-0.493,-0.471,-0.450,-0.428,-0.405,-0.383,-0.360,-0.337,-0.314,-0.290,-0.267,-0.243,-0.219,-0.195,-0.171,-0.147,-0.122,-0.098,-0.074,-0.049,-0.025};
    
    //Real part of the time domain signal
    int x_r   [256] = {-1037,-1264,1183,1283,-581,1256,-804,367,-1394,-1412,1106,-1426,1393,287,1001,1145,446,-1289,981,-1399,-639,1411,-1123,1335,-697,-894,858,-519,-639,-1072,-765,1420,-808,-1385,-1257,-1059,-737,-707,-1376,-1414,-403,-546,-914,-988,1033,276,386,616,773,-887,-810,-699,638,-1093,1203,254,1399,649,-463,940,878,-862,-265,748,1227,-1398,368,1153,-1127,-856,-1102,864,-1036,891,1323,-625,-1009,-872,540,317,621,-1077,-463,-374,1293,-785,-893,-884,-549,420,-1310,-1365,-327,-948,-1335,-1175,-422,-327,-1470,-657,-1095,986,-722,-321,1086,505,-843,635,723,-870,-374,1290,928,-1283,1119,-1065,-346,-1490,1305,393,-1233,1405,1488,937,1043,1172,-1289,-501,850,-1000,421,-1277,-1045,840,-1136,-1160,1173,-449,375,-1138,-1133,-555,-623,283,-495,1310,-900,-1192,-1040,-900,-457,1376,1257,1362,-273,277,656,1250,577,1222,-951,-526,896,490,1259,-1170,1355,-1390,-438,1351,-913,-617,1053,1461,-1392,1078,-623,-829,-619,-373,-368,759,-862,1028,717,1041,579,564,-951,-1297,-1323,-939,283,410,383,734,271,-277,-1044,987,-611,-553,1029,332,-623,1348,-1190,-375,-556,468,-981,747,323,924,-1111,-1013,-935,-1073,-931,411,722,1308,-424,1038,1262,1449,403,1222,-855,-478,487,844,-507,-778,-946,-1206,-758,703,440,270,-1286,-844,1003,-1427,1322,-826,-278,446,-907,353,1408,367,-303,-921,-278,-560};
    //Imaginary part of time domain signal
    int x_i   [256] = {0};
    
    //The real part of the frequency domain signal
    int y_r   [256] = {0};
    //Imaginary part of frequency domain signal
    int y_i   [256] = {0};

    //Frequency domain signal modulus
    //H[i] = sqrt(y_r*y_r + y_i*y_i)
    int H [256] = {0};

    //Butterfly calculation result with odd order
    int odd_r [256] = {0};
    int odd_i [256] = {0};
    
    //Butterfly calculation result with even order
    int eve_r [256] = {0};
    int eve_i [256] = {0};

    int i,j,k;
    int result;     //result  = (int)(100*log(H[0]))
    int N = 256;    //fft points


/*The commented out paragraph is a flashback of 
the time domain signal, which will not affect the log calculation*/
/*    
    int,k,m,n,Temp,F0,F1;
for(i=0;i<N;i++)   //根据规律四，需要对数组全部元素执行码间倒序
{  
  j=0;
  for(k=0;k<(M/2+0.5);k++)     //k表示操作
     {
        m=1;//m是最低位为1的二进制数
        n=(unsigned int)pow(2,M-1);//n是第M位为1的二进制数
        m <<= k; //对m左移k位
        n>>= k; //对n右移k位
        F0=i & n;//I与n按位与提取出前半部分第k位
        F1=i & m;//I与m按位与提取出F0对应的后半部分的低位
        if(F0) j=j | m; //J与m按位或使F0对应低位为1
        if(F1) j=j | n; //J与n按位或使F1对应高位为1
     }
   if(i<j)
    {
      Temp=x_r[i];
      x_r[i] =x_r[j];
      x_r[j]=Temp;
    }                                
}
*/

//k from 0 to 7 represents the current operation order of fft
    k = 0;
    for (i = 0; i < N; i+=2 ) 
    {
        for (j = 0; j < 1; j++)
        {
            butterfly(&x_r[i+j],&x_i[i+j],&x_r[i+j+1],&x_i[i+j+1] , &odd_r[i+j],&odd_i[i+j],&odd_r[i+j+1],&odd_i[i+j+1] , w_r[j*128],w_i[j*128]);
        }
        
    }    

    k = 1;
    for (i = 0; i < N; i+=4 ) 
    {
        for (j = 0; j < 2; j++)
        {
            butterfly(&odd_r[i+j],&odd_i[i+j],&odd_r[i+j+2],&odd_i[i+j+2] , &eve_r[i+j],&eve_i[i+j],&eve_r[i+j+2],&eve_i[i+j+2] , w_r[j*64],w_i[j*64]);
        }
        
    }
    
    k = 2;
    for (i = 0; i < N; i+=8 ) 
    {
        for (j = 0; j < 4; j++)
        {
            butterfly(&eve_r[i+j],&eve_i[i+j],&eve_r[i+j+4],&eve_i[i+j+4] , &odd_r[i+j],&odd_i[i+j],&odd_r[i+j+4],&odd_i[i+j+4] , w_r[j*32],w_i[j*32]);
        }
        
    }    
    
    k = 3;
    for (i = 0; i < N; i+=16 ) 
    {
        for (j = 0; j < 8; j++)
        {
            butterfly(&odd_r[i+j],&odd_i[i+j],&odd_r[i+j+8],&odd_i[i+j+8] , &eve_r[i+j],&eve_i[i+j],&eve_r[i+j+8],&eve_i[i+j+8] , w_r[j*16],w_i[j*16]);
        }
        
    }

    k = 4;
    for (i = 0; i < N; i+=32 ) 
    {
        for (j = 0; j < 16; j++)
        {
            butterfly(&eve_r[i+j],&eve_i[i+j],&eve_r[i+j+16],&eve_i[i+j+16] , &odd_r[i+j],&odd_i[i+j],&odd_r[i+j+16],&odd_i[i+j+16] , w_r[j*8],w_i[j*8]);
        }
        
    }    
    
    k = 5;
    for (i = 0; i < N; i+=64 ) 
    {
        for (j = 0; j < 32; j++)
        {
            butterfly(&odd_r[i+j],&odd_i[i+j],&odd_r[i+j+32],&odd_i[i+j+32] , &eve_r[i+j],&eve_i[i+j],&eve_r[i+j+32],&eve_i[i+j+32] , w_r[j*4],w_i[j*4]);
        }
        
    }
    
    k = 6;
    for (i = 0; i < N; i+=128 ) 
    {
        for (j = 0; j < 64; j++)
        {
            butterfly(&eve_r[i+j],&eve_i[i+j],&eve_r[i+j+64],&eve_i[i+j+64] , &odd_r[i+j],&odd_i[i+j],&odd_r[i+j+64],&odd_i[i+j+64] , w_r[j*2],w_i[j*2]);
        }
        
    }    
    
    k = 7;
    for (i = 0; i < N; i+=256 ) 
    {
        for (j = 0; j < 128; j++)
        {
            butterfly(&odd_r[i+j],&odd_i[i+j],&odd_r[i+j+128],&odd_i[i+j+128] , &y_r[i+j],&y_i[i+j],&y_r[i+j+128],&y_i[i+j+128] , w_r[j],w_i[j]);
        }
    }

//Calculate the modulus of the fft result
    for (i = 0; i < N; i++ )
    {
        H[i] = (int)sqrt(y_r[i]*y_r[i] + y_i[i]*y_i[i]);
    }


    result = (int)(100*log(H[0]));

    printfNexys("H[0] =%d", H[0] );
    printfNexys("result = 100*log(H[0]) =%d", result );


    while(1);
}